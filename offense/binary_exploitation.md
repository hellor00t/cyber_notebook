# Binary Exploitation

## Educational Material

#### LiveOverflow Beginner Playlist

* [https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=1](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=1)

#### Challenges

* [https://exploit.education/](https://exploit.education/)
* [https://pwnable.xyz/](https://pwnable.xyz/)

## CPU Concepts

* [https://sockpuppet.org/issue-79-file-0xb-foxport-hht-hacking.txt.html](https://sockpuppet.org/issue-79-file-0xb-foxport-hht-hacking.txt.html)

## Assembly Primer

```text
--[ assembly programming ]-----------

Assembly language is more intimidating than it is hard. I can sum it up 
for you very briefly:

* You're given 8-32 global variables of fixed size to work with, called 
"registers".

* There are special registers. The most important is the "Program 
Counter", which tells the CPU which instruction we're executing next. 
Every time we execute an instruction, we advance the program counter.

MY_NOTE: Intel x86 architecture instruction pointer - RIP, eip, ip


* Virtually all computation is expressed in terms of simple operations 
on registers.

* Real programs need many more than 32 1-byte variables to work with.

* What doesn't fit in registers lives in memory.

* Memory is accessed either with loads and stores at addresses, as if it 
were a big array, or through PUSH and POP operations on a stack.

(mov, eax[14])

* Memory is to an assembly program what the disk is to a Ruby program: 
you pull things out of memory into variables, do things with them, and 
eventually put them back into memory.

MY_NOTE: Stack pointer = sp, esp, rsp

* Control flow is done via GOTOs --- jumps, branches, or calls. The 
effect of these instructions is to alter the program counter directly.

MY_NOTE: jump - branch - call jmp, jne, je. bne, be, call

* A jump is just an unconditional GOTO.

* Most operations on registers, like addition and subtraction, have the 
side effect of altering status flags, like "the last value computed 
resulted in zero". There are just a few status flags, and they usually 
live in a special register.

* Branches are just GOTOs that are predicated on a status flag, like, 
"GOTO this address only if the last arithmetic operation resulted in 
zero".

MY_NOTE: branch (if) equal to zero == beq
jump (if) equal / zero == je, jz

* A CALL is just an unconditional GOTO that pushes the next address on 
the stack, so a RET instruction can later pop it off and keep going 
where the CALL left off.
```

## Tools

* gdb
* radare2
* hopper \(mac\)
* binaryninja

### GDB Cheatsheet

`gdb <binary>` - Load binary into gnu debugger \(gdb\) `set disassembly-flavor intel` - Set output to intel `diassemble main` - Disassemble main codeblock `break main` - Set breakpoint at main `break *<address>` - Set breakpoint at address `run` - Run binary `info registers` - Look at registers `si` - Step one instruction `ni` - Next instruction only in main function `run <argument>` - run binary with an argument `continue` - run program until next breakpoint `set $eax=0` - set eax register to 0 `info proc mappings` - look at mapped memory \(stack\) `x/wx $esp` - examine memory of ESP w\(word\) x\(hex\)

## ObjectDump

`objdump -d <binary>` - disassemble binary

`objdump -x <binary>` - print headers to stdout

## strace - intercepts and records system calls

`strace ./<binary>`

## ltrace - traces libary functions

`ltrace ./<binary>`

## radare2

`r2 <binary>` - start radare2 `r2 -d <binary>` - debug program `db <address>` - set break point `:` - command mode `dc` - run program `shift+s` or `shift+S` - step forward `aaa` - auto analyze and alter name functions `afl` - print all functions `s <function>` - seek to function location `pdf` - print disassembly of current function `VV` - visual mode \(tab and shift-tab, select other box\), \(shift + hjkl, move boxes\), \(p - cycle through views\), \(? - help\)

